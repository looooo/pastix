extern "C" %{
  /**
   * PLASMA include for defined and constants.
   *
   * @precisions normal z -> s d c
   *
   */
#include <plasma.h>
#include <core_blas.h>

#include "parsec.h"
#include "data_distribution.h"
#include "memory_pool.h"
#include "dplasma/lib/dplasmajdf.h"

#include "data_dist/sparse-matrix/pastix_internal/pastix_internal.h"
#include "data_dist/sparse-matrix/sparse-matrix.h"
#include "dsparse/cores/dsparse_zcores.h"

#undef printf

%}

/* Globals
 */
descA    [type = "sparse_matrix_desc_t *"]
descB    [type = "sparse_vector_desc_t *"]
datacode [type = "SolverMatrix*" default="&(descA->pastix_data->solvmatr)" hidden=on]
/* Number of column blocks */
cblknbr  [type = "parsec_int_t"   default="descA->pastix_data->solvmatr.cblknbr - 1" hidden=on]
/* Number of blocks minus the last diagonal block */
bloknbr  [type = "parsec_int_t"   default="descA->pastix_data->solvmatr.bloknbr - 2" hidden=on]
/* Number of extra diagonal blocks */
browsize [type = "parsec_int_t"   default="descA->pastix_data->solvmatr.bloknbr - descA->pastix_data->solvmatr.cblknbr - 1" hidden=on]
p_work   [type = "parsec_memory_pool_t *" size = "datacode->coefmax * sizeof(parsec_complex64_t)"]

/**************************************************
 *                TRSM_FORWARD                    *
 **************************************************/
TRSM_FORWARD(k)

// Execution space
k = 0..cblknbr
gcblk2list= inline_c %{ return UPDOWN_GCBLK2LIST(UPDOWN_LOC2GLOB( k )); %}
firstblok = inline_c %{ return SYMB_BLOKNUM(k); %}      // diagonal
lastblok  = inline_c %{ return SYMB_BLOKNUM(k+1)-1; %}  // last block of the column
browk1    = inline_c %{ if ( gcblk2list != -1 ) return UPDOWN_LISTPTR( gcblk2list+1 ); else return -1; %}
lastbrow  = inline_c %{ if (browk1 > 0) return UPDOWN_LISTBLOK(browk1-1); else return 0; %}

// Parallel partitioning
:descB(k) // Should match SOLV_COEFTAB(k)

// Parameters
/* C is descA(k) if it's a leaf or get the cblk from the last update */
READ A <- descA(0, k)
RW   B <- ( gcblk2list < 0 ) ? descB(k) : C GEMM_FORWARD( lastbrow )
       -> B GEMM_FORWARD(firstblok+1..lastblok)
       -> (firstblok == lastblok) ? B TRSM_BACKWARD(k) : descB(k)

BODY
      DRYRUN(
             int tempm = SYMB_LCOLNUM(k)-SYMB_FCOLNUM(k)+1;
             int tempn = UPDOWN_SM2XNBR;

             /* Compute the contribution */
             CORE_ztrsm( PlasmaLeft, PlasmaLower, PlasmaNoTrans, PlasmaNonUnit,
                         tempm, tempn,
                         1.,  A, SOLV_STRIDE(k),
                              B, UPDOWN_SM2XSZE);

             );

      printlog(
               "thread %d solvedown_1dplus( cblknum=%d, browk1=%d, lastbrow=%d, firstblok=%d, lastblok=%d )\n",
               context->eu_id, k, /*browk, */ browk1, lastbrow, firstblok, lastblok);

END

/**************************************************
 *              GEMM_FORWARD                      *
 **************************************************/

GEMM_FORWARD(k)

// Execution space
k = 0..bloknbr
fcblk  = inline_c %{ return SYMB_CBLKNUM(k); %}
cblk   = inline_c %{ return sparse_matrix_get_lcblknum( descA, (parsec_int_t)k ); %}// TODO: store cblknum in symbblok
phony  = inline_c %{ return k == SYMB_BLOKNUM( cblk ); %}
prev   = inline_c %{ if (phony) return 0; else return sparse_matrix_get_listptr_prev( descA, (parsec_int_t)k, (parsec_int_t)fcblk ); %}
next   = inline_c %{ if (phony) return 0; else return sparse_matrix_get_listptr_next( descA, (parsec_int_t)k, (parsec_int_t)fcblk ); %}

// Parallel partitioning: empty if SYMB_LROWNUM(k)==SYMB_FCOLNUM(fcblk)
:descB(fcblk)

// Parameters
READ  A <- descA(0, cblk)
READ  B <- phony ? descB(fcblk) : B TRSM_FORWARD(cblk) // B never comes from memory but we keep it for correctness of the code
RW    C <- ( prev == 0 ) ? descB(fcblk) : C GEMM_FORWARD( prev )
        -> phony ? descB(fcblk)                        // B never go back to memory but we keep it for correctness of the code
        -> ((!phony) && (next == 0)) ? B TRSM_FORWARD( fcblk )
        -> ((!phony) && (next != 0)) ? C GEMM_FORWARD( next )

BODY
      if (!phony) {

          DRYRUN(
                 /* shifting to a off-diagonal block within this column */
                 parsec_complex64_t *Aik = ((parsec_complex64_t*)A) + SOLV_COEFIND(k);
                 /* shifting to a sub-block within the block */
                 parsec_complex64_t *Cik = ((parsec_complex64_t*)C) + (SYMB_FROWNUM( k ) - SYMB_FCOLNUM(fcblk));

                 int tempm = SYMB_LROWNUM(k)-SYMB_FROWNUM(k)+1;
                 int tempn = UPDOWN_SM2XNBR;
                 int tempk = SYMB_LCOLNUM(cblk)-SYMB_FCOLNUM(cblk)+1;

                 CORE_zgemm( PlasmaNoTrans, PlasmaNoTrans,
                             tempm, tempn, tempk,
                             -1.,  Aik,  SOLV_STRIDE(cblk),
                                   B,    UPDOWN_SM2XSZE,
                             1.,   Cik,  UPDOWN_SM2XSZE);
                 );
          printlog(
                   "thread %d compute_1dgemm( k=%d, fcblk=%d, cblk=%d, prev=%d, next=%d )\n",
                   context->eu_id, k, fcblk, cblk, prev, next);
      } else {
          printlog(
                   "thread %d phony_gemm( k=%d, fcblk=%d, cblk=%d, prev=%d, next=%d )\n",
                   context->eu_id, k, fcblk, cblk, prev, next);
      }
END



/**************************************************
 *                TRSM_BACKWARD                    *
 **************************************************/

TRSM_BACKWARD(k)

// Execution space
k = 0..cblknbr
gcblk2list= inline_c %{ return UPDOWN_GCBLK2LIST(UPDOWN_LOC2GLOB( k )); %}
firstbrow = inline_c %{ if ( gcblk2list != -1 ) return UPDOWN_LISTPTR( gcblk2list   ); else return -1; %}
lastbrow  = inline_c %{ if ( gcblk2list != -1 ) return UPDOWN_LISTPTR( gcblk2list+1 )-1; else return -1; %}
firstblok = inline_c %{ return SYMB_BLOKNUM(k)+1; %}
lastblok  = inline_c %{ return SYMB_BLOKNUM(k+1); %}
browk = inline_c %{
    {
        if (firstblok == lastblok) return -1;

        parsec_int_t fcblk       = SYMB_CBLKNUM( firstblok );
        parsec_int_t gfcblk2list = UPDOWN_GCBLK2LIST(UPDOWN_LOC2GLOB( fcblk ));
        parsec_int_t browfirst   = UPDOWN_LISTPTR( gfcblk2list );
        parsec_int_t browlast    = UPDOWN_LISTPTR( gfcblk2list + 1 );
        int count;

        for (count=browlast-1; count>=browfirst; count--)
            if (firstblok == UPDOWN_LISTBLOK(count)) return count;

        assert(0);
        return -1;
    }
%}

// Parallel partitioning
:descB(k) // Should match SOLV_COEFTAB(k)

// Parameters
// C is descA(k) if it's a leaf or get the cblk from the last update
READ A <- descA(0, k)
RW   B <- ( lastblok == firstblok ) ? B TRSM_FORWARD( k ) : C GEMM_BACKWARD( browk )
       -> ( gcblk2list >= 0 ) ? B GEMM_BACKWARD( firstbrow..lastbrow )
       -> descB(k)

BODY

      DRYRUN(
             int tempm = SYMB_LCOLNUM(k)-SYMB_FCOLNUM(k)+1;
             int tempn = UPDOWN_SM2XNBR;

             // Compute the contribution
             CORE_ztrsm( PlasmaLeft, PlasmaLower, PlasmaConjTrans, PlasmaNonUnit,
                         tempm, tempn,
                         1.,  A, SOLV_STRIDE(k),
                              B, UPDOWN_SM2XSZE);
             );
      printlog(
               "thread %d solvedown_1dplus( cblknum=%d )\n",
               context->eu_id, k);

END


/**************************************************
 *                      GEMM_BACKWARD                      *
 **************************************************/

GEMM_BACKWARD(k)

// Execution space
k = 0..browsize
bloknum= inline_c %{ return UPDOWN_LISTBLOK(k); %}
fcblk  = inline_c %{ return SYMB_CBLKNUM(bloknum); %}
cblk   = inline_c %{ return sparse_matrix_get_lcblknum( descA, (parsec_int_t)bloknum ); %}
firstblok = inline_c %{ return SYMB_BLOKNUM(cblk)+1; %}
lastblok  = inline_c %{ return SYMB_BLOKNUM(cblk+1); %}

gcblk2list= inline_c %{ return UPDOWN_GCBLK2LIST(UPDOWN_LOC2GLOB( fcblk )); %}
firstbrow = inline_c %{ assert( gcblk2list != -1 ); return UPDOWN_LISTPTR( gcblk2list   ); %}
lastbrow  = inline_c %{ assert( gcblk2list != -1 ); return UPDOWN_LISTPTR( gcblk2list+1 )-1; %}
prev = inline_c %{
    {
        if( bloknum == lastblok-1 ) return -1;

        parsec_int_t fcblk       = SYMB_CBLKNUM( bloknum+1 );
        parsec_int_t gfcblk2list = UPDOWN_GCBLK2LIST(UPDOWN_LOC2GLOB( fcblk ));
        parsec_int_t browfirst   = UPDOWN_LISTPTR( gfcblk2list );
        parsec_int_t browlast    = UPDOWN_LISTPTR( gfcblk2list + 1 );
        int count;

        for (count=browfirst; count<browlast; count++)
            if (bloknum+1 == UPDOWN_LISTBLOK(count)) return count;

        printf( " prev(%d) failed\n",cblk );
        assert(0);
    }
    return -1;
%}
next = inline_c %{
    {
        if( bloknum == firstblok ) return -1;

        parsec_int_t fcblk       = SYMB_CBLKNUM( bloknum-1 );
        parsec_int_t gfcblk2list = UPDOWN_GCBLK2LIST(UPDOWN_LOC2GLOB( fcblk ));
        parsec_int_t browfirst   = UPDOWN_LISTPTR( gfcblk2list );
        parsec_int_t browlast    = UPDOWN_LISTPTR( gfcblk2list + 1 );
        int count;

        for (count=browfirst; count<browlast; count++)
            if (bloknum-1 == UPDOWN_LISTBLOK(count)) return count;

        assert(0);
    }
    return -1;
%}

// Parallel partitioning
:descB(cblk)

// Parameters
READ  A <- descA(0, cblk)
READ  B <- B TRSM_BACKWARD(fcblk)

RW    C <- ( bloknum == lastblok-1 ) ?  descB( cblk )               : C GEMM_BACKWARD( prev )
        -> ( bloknum == firstblok  ) ?  B TRSM_BACKWARD( cblk ) : C GEMM_BACKWARD( next )

BODY

    DRYRUN(
           parsec_complex64_t *Aik = ((parsec_complex64_t*)A) + SOLV_COEFIND(bloknum);
           parsec_complex64_t *Bik = ((parsec_complex64_t*)B) + (SYMB_FROWNUM( bloknum ) - SYMB_FCOLNUM(fcblk));

           int tempm = SYMB_LCOLNUM(cblk)-SYMB_FCOLNUM(cblk)+1;
           int tempn = UPDOWN_SM2XNBR;
           int tempk = SYMB_LROWNUM(bloknum)-SYMB_FROWNUM(bloknum)+1;

           CORE_zgemm( PlasmaConjTrans, PlasmaNoTrans,
                       tempm, tempn, tempk,
                       -1.,  Aik,  SOLV_STRIDE(cblk),
                             Bik,  UPDOWN_SM2XSZE,
                        1.,  C,    UPDOWN_SM2XSZE);
           );
    printlog(
             "thread %d compute_1dgemm( k=%d, bloknum=%d, fcblk=%d, cblk=%d )\n",
             context->eu_id, k, bloknum, fcblk, cblk);
END

