cmake_minimum_required (VERSION 2.8)
project (PASTIX C CXX Fortran)
enable_testing()

include(CMakeDependentOption)
include(CheckFunctionExists)

# The current version number
set (PASTIX_VERSION_MAJOR 5)
set (PASTIX_VERSION_MINOR 1)
set (PASTIX_VERSION_MICRO 0)

set( PASTIX_VERSION "${PASTIX_VERSION_MAJOR}.${PASTIX_VERSION_MINOR}.${PASTIX_VERSION_MICRO}" )

# Add extra cmake module path and initialize morse cmake modules
# --------------------------------------------------------------
list(APPEND CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake_modules)

set( MORSE_CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake_modules/morse )
list(APPEND CMAKE_MODULE_PATH ${MORSE_CMAKE_MODULE_PATH})
include(MorseInit)

# Define precision supported by MAGMA_MORSE
# -----------------------------------------
set( RP_PASTIX_DICTIONNARY ${MORSE_CMAKE_MODULE_PATH}/precision_generator/subs.py )
set( RP_PASTIX_PRECISIONS  "s;d;c;z" )
include(CheckIncludeFiles)
check_include_files(complex.h HAVE_COMPLEX_H)

include(RulesPrecisions)

# # CTest system
# SET(DART_TESTING_TIMEOUT 120)
# enable_testing()
# include(CTest)
# enable_testing()

### Misc options
option(BUILD_SHARED_LIBS
  "Build shared libraries" OFF)
option(BUILD_64bits
  "Build 64 bits mode" ON)
if(NOT CMAKE_BUILD_TYPE)
  set(CMAKE_BUILD_TYPE RelWithDebInfo CACHE STRING "Choose the type of build, options are None, Debug, Release, RelWithDebInfo and MinSizeRel." FORCE)
endif(NOT CMAKE_BUILD_TYPE)

### Distributed engine parameters
find_package(MPI)
if (MPI_FOUND)
  option(PASTIX_WITH_MPI
    "Build PaStiX for distributed memory with MPI" ON)
else (MPI_FOUND)
  option(PASTIX_WITH_MPI
    "Build PaStiX for distributed memory with MPI" OFF)
endif(MPI_FOUND)


### GPU engine parameters
find_package(CUDA)
if (CUDA_FOUND)
  option(PASTIX_WITH_CUDA
    "Enable GPU support using CUDA kernels" ON)
else (CUDA_FOUND)
  option(PASTIX_WITH_CUDA
    "Enable GPU support using CUDA kernels" OFF)
endif(CUDA_FOUND)

#Search for StarPU
# create list of components in order to make a single call to find_package(starpu...)
set(STARPU_COMPONENT_LIST "HWLOC")
if(PASTIX_WITH_MPI)
  list(APPEND STARPU_COMPONENT_LIST "MPI")
endif(PASTIX_WITH_MPI)

if(PASTIX_WITH_CUDA)
  list(APPEND STARPU_COMPONENT_LIST "CUDA")
endif(PASTIX_WITH_CUDA)

find_package(STARPU "1.1"
  COMPONENTS ${STARPU_COMPONENT_LIST})
if (STARPU_FOUND)
  option(PASTIX_WITH_STARPU
    "Build PaStiX with StarPU runtime support" ON)
else (STARPU_FOUND)
  option(PASTIX_WITH_STARPU
    "Build PaStiX with StarPU runtime support" OFF)
endif(STARPU_FOUND)
option(PASTIX_WITH_STARPU_PROFILING
  "Build PaStiX with StarPU runtime support profiling" OFF)

option(PASTIX_DUMP_CBLK
  "Dump all cblk on disk after modifications" OFF)

cmake_dependent_option(PASTIX_DISTRIBUTED
 "Enable the distributed interface (requires PASTIX_WITH_MPI)" ON "PASTIX_WITH_MPI" OFF)

cmake_dependent_option(PASTIX_THREAD_COMM
 "Enable the specific communication thread (requires PASTIX_WITH_MPI)" ON "PASTIX_WITH_MPI" OFF)

option(PASTIX_INT64
  "Choose between int32 and int64 for integer representation" ON)

# Precisions generated
if(NOT PASTIX_PRECISIONS)
  set(PASTIX_PRECISIONS "s;d;c;z" CACHE STRING "The precisions to compile in PaSTiX (accepts a colon separated list of s;d;c;z)" FORCE)
else()
  set(PASTIX_PRECISIONS "${PASTIX_PRECISIONS}" CACHE STRING "The precisions to compile in PaSTiX (accepts a colon separated list of s;d;c;z)" FORCE)
endif()

# Ordering step options
option(PASTIX_ORDERING_SCOTCH
  "Enable Scotch Ordering" ON)
option(PASTIX_ORDERING_METIS
  "Enable Metis ordering"  OFF)
cmake_dependent_option(PASTIX_ORDERING_PTSCOTCH
  "Activate the PT-scotch ordering (requires PASTIX_DISTRIBUTED and PASTIX_ORDERING_SCOTCH)" ON
  "PASTIX_DISTRIBUTED;PASTIX_ORDERING_SCOTCH" OFF)

mark_as_advanced(FORCE SCOTCH_DIR METIS_DIR BLAS_LIBRARY_DIRS BLAS_LIBRARIES)
set( SCOTCH_DIR        /opt/scotch                 CACHE PATH   "Scotch prefix directory")
set( METIS_DIR         /opt/metis                  CACHE PATH   "Metis prefix directory" )

#set( BLAS_LIBRARY_DIRS /opt/plasma-extlibs-dbg/lib CACHE STRING "BLAS library paths"     )
#set( BLAS_LIBRARIES    refblas                     CACHE STRING "BLAS libraries"         )
#set( CBLAS_DIR         /opt/plasma-extlibs-dbg     CACHE STRING "CBLAS path"     )
#set( CBLAS_LIBRARIES    cblas                       CACHE STRING "CBLAS libraries"         )
#set( BLAS_LIBRARY_DIRS /opt/gotoblas2              CACHE STRING "BLAS library paths"     )
#set( BLAS_LIBRARIES    goto2                       CACHE STRING "BLAS libraries"         )

# Symbolic factorization options
option(PASTIX_SYMBOL_DUMP_SYMBMTX
  "Dump the generated symbol matrix in a postscript file" OFF)
option(PASTIX_SYMBOL_FORCELOAD
  "Force the symbol matrix to be loaded from file" OFF)

# Options to check
option(FORGET_PARTITION
  "Force to forget the partition generated by Scotch" OFF)
option(COMPACT_SMX
  "Optimization for solve computations (TODO: check if not obsolete because results don't converge)" OFF)

#
# Find non-optional packages
#
find_package(BLASEXT REQUIRED)
set(HAVE_BLAS ${BLAS_FOUND})

find_package(CBLAS REQUIRED)
set(HAVE_CBLAS ${CBLAS_FOUND})
if(CBLAS_FOUND)
  message(STATUS "cblas: ${CBLAS_INCLUDE_DIRS}")
    include_directories(${CBLAS_INCLUDE_DIRS})
endif()

find_package(HWLOC)
set(HAVE_HWLOC ${HWLOC_FOUND})
if( HWLOC_FOUND )
  # list(APPEND EXTRA_SOURCES src/dague_hwloc.c)
  list(APPEND EXTRA_LIBS ${HWLOC_LIBRARIES})
  include_directories( ${HWLOC_INCLUDE_DIRS} )
endif (HWLOC_FOUND)

set(CMAKE_THREAD_PREFER_PTHREAD TRUE)
find_package(Threads REQUIRED)
list(APPEND EXTRA_LIBS
  ${CMAKE_THREAD_LIBS_INIT})

FIND_LIBRARY(RT rt)
list(APPEND EXTRA_LIBS
  ${RT})

set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Drestrict=")
set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -DCUDA_SM_VERSION=20")
#
# Find optional packages
#
if (PASTIX_WITH_MPI)
  if (NOT MPI_FOUND)
    message(FATAL_ERROR
      "MPI is required to build PaStiX with MPI support.")
  endif(NOT MPI_FOUND)
  set(HAVE_MPI TRUE)
  include_directories( ${MPI_INCLUDE_PATH} )
##  set(CMAKE_REQUIRED_INCLUDES ${MPI_INCLUDE_PATH})
##  set(CMAKE_REQUIRED_LIBRARIES ${MPI_LIBRARIES})
##  check_function_exists(MPI_Get_address HAVE_MPI_GET_ADDRESS)
##  if (${HAVE_MPI_GET_ADDRESS})
##    message(STATUS "HAVE_MPI_GET_ADDRESS -- True")
##  else(${HAVE_MPI_GET_ADDRESS})
##    message(STATUS "HAVE_MPI_GET_ADDRESS -- False ${MPI_INCLUDE_PATH} ${MPI_LIBRARIES}")
##  endif(${HAVE_MPI_GET_ADDRESS})
endif (PASTIX_WITH_MPI)

if (PASTIX_WITH_STARPU)
  if (NOT STARPU_FOUND)
    message(FATAL_ERROR
      "StarPU is required to build PaStiX with StarPU support.")
  endif(NOT STARPU_FOUND)

  set(HAVE_STARPU ${STARPU_FOUND})
  if (STARPU_FOUND)
    if(PASTIX_WITH_MPI)
      set(CMAKE_REQUIRED_LIBRARIES
	"${CMAKE_REQUIRED_LIBRARIES};${STARPU_MPI_LIBRARIES}")
      include_directories( ${STARPU_MPI_INCLUDE_DIRS} )
    else(PASTIX_WITH_MPI)
      set(CMAKE_REQUIRED_LIBRARIES
	"${CMAKE_REQUIRED_LIBRARIES};${STARPU_SHM_LIBRARIES}")

      include_directories( ${STARPU_SHM_INCLUDE_DIRS} )
    endif(PASTIX_WITH_MPI)
    include_directories( ${STARPU_INCLUDE_DIRS} )
  endif (STARPU_FOUND)

  # if (STARPU_CUDA_FOUND)
  #   set(PASTIX_WITH_CUDA ON)
  # endif(STARPU_CUDA_FOUND)
endif (PASTIX_WITH_STARPU)

#
if (PASTIX_ORDERING_SCOTCH OR PASTIX_ORDERING_PTSCOTCH)
  include_directories("${SCOTCH_DIR}/include")
  set(SCOTCH_LIBRARY_DIRS "${SCOTCH_DIR}/lib")
  set(SCOTCH_LIBRARIES    "scotch;scotcherr")
  set(PTSCOTCH_LIBRARIES  "ptscotch;ptscotcherr")
endif()


if (PASTIX_ORDERING_METIS)
  include_directories("${METIS_DIR}/include")
  set(METIS_LIBRARY_DIRS "${METIS_DIR}/lib")
  set(METIS_LIBRARIES    "metis")
endif()

# Check to see if support for MPI 2.0 is available
#
if (MPI_FOUND)
  set(saved_include "${CMAKE_REQUIRED_INCLUDES}" )
  set(saved_libs    "${CMAKE_REQUIRED_LIBRARIES}")
  set(CMAKE_REQUIRED_INCLUDES  "${CMAKE_REQUIRED_INCLUDES};${MPI_C_INCLUDE_PATH}")
  set(CMAKE_REQUIRED_LIBRARIES "${CMAKE_REQUIRED_LIBRARIES};${MPI_C_LIBRARIES}")
  check_function_exists(MPI_Type_create_resized HAVE_MPI_20)
  set(CMAKE_REQUIRED_INCLUDES  "${saved_include}")
  set(CMAKE_REQUIRED_LIBRARIES "${saved_libs}")
endif (MPI_FOUND)

if( PASTIX_WITH_CUDA )
  set(HAVE_CUDA ${CUDA_FOUND})
  if (NOT CUDA_FOUND)
    message(FATAL_ERROR
      "CUDA is required to build PaStiX with CUDA support.")
  endif(NOT CUDA_FOUND)
  
  if (CUDA_FOUND)
    if(CUDA_VERSION VERSION_LESS "3.0")
      set(CUDA_HOST_COMPILATION_CPP OFF)
    endif(CUDA_VERSION VERSION_LESS "3.0")
    set(CUDA_BUILD_EMULATION OFF)
    include_directories(${CUDA_INCLUDE_DIRS})
    set(saved_include "${CMAKE_REQUIRED_INCLUDES}")
    set(saved_libs    "${CMAKE_REQUIRED_LIBRARIES}")
    set(CMAKE_REQUIRED_INCLUDES  "${CMAKE_REQUIRED_INCLUDES};${CUDA_INCLUDE_DIRS}")
    set(CMAKE_REQUIRED_LIBRARIES "${CMAKE_REQUIRED_LIBRARIES};${CUDA_LIBRARIES}")
    if(CUDA_VERSION VERSION_LESS "4.0")
      set(DAGUE_HAVE_PEER_DEVICE_MEMORY_ACCESS 0)
    else()
      check_function_exists(cuDeviceCanAccessPeer DAGUE_HAVE_PEER_DEVICE_MEMORY_ACCESS)
    endif()
    set(CMAKE_REQUIRED_INCLUDES  "${saved_include}")
    set(CMAKE_REQUIRED_LIBRARIES "${saved_libs}")
  endif (CUDA_FOUND)
endif( PASTIX_WITH_CUDA )

#
##
###
# Finished detecting the system, lets do our own things now
###
##
#
set(PROJECT_INCLUDE_DIR "${CMAKE_CURRENT_BINARY_DIR}/include")
include_directories(BEFORE "${PROJECT_INCLUDE_DIR}")

STRING(COMPARE EQUAL ${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_CURRENT_SOURCE_DIR} PROJECT_COMPILE_INPLACE)
if(NOT PROJECT_COMPILE_INPLACE)
  include_directories(BEFORE "${CMAKE_CURRENT_SOURCE_DIR}/include")
endif(NOT PROJECT_COMPILE_INPLACE)

#Configuration header
configure_file (
  "${CMAKE_CURRENT_SOURCE_DIR}/include/pastix/config.h.in"
  "${PROJECT_INCLUDE_DIR}/pastix/config.h")
install(FILES "${PROJECT_INCLUDE_DIR}/pastix/config.h" DESTINATION include/pastix)

# # pkg-config file
# configure_file (
#   "${CMAKE_CURRENT_SOURCE_DIR}/include/pastix.pc.in"
#   "${CMAKE_BINARY_DIR}/lib/pkgconfig/pastix.pc")
# install(FILES "${CMAKE_BINARY_DIR}/lib/pkgconfig/pastix.pc" DESTINATION lib/pkgconfig)

add_definitions(-DDOF_CONSTANT)
add_definitions(-DX_ARCHi686_pc_linux)

execute_process(COMMAND "./myversion.sh" OUTPUT_VARIABLE PASTIX_VERSION)
set(TOTO "-DVERSION=\"toto\"" )
add_definitions(${TOTO})

# Build matrix drivers library
#
#add_subdirectory(tools)
#add_subdirectory(matrix_drivers)

include_directories("${CMAKE_CURRENT_SOURCE_DIR}/include")
include_directories("${CMAKE_CURRENT_SOURCE_DIR}/common")
include_directories("${CMAKE_CURRENT_SOURCE_DIR}/graph")
include_directories("${CMAKE_CURRENT_SOURCE_DIR}/fax")
include_directories("${CMAKE_CURRENT_SOURCE_DIR}/graph")
include_directories("${CMAKE_CURRENT_SOURCE_DIR}/kass")
include_directories("${CMAKE_CURRENT_SOURCE_DIR}/order")
include_directories("${CMAKE_CURRENT_SOURCE_DIR}/symbol")

include_directories("${CMAKE_CURRENT_BINARY_DIR}/include")
include_directories("${CMAKE_CURRENT_BINARY_DIR}/common")

# Sub modules
set(modules libcsc blend csc kernels sopalin matrix_drivers include common murge)
if (PASTIX_WITH_STARPU)
  list(APPEND modules starpu)
endif (PASTIX_WITH_STARPU)
# For each modules add -I compilation flag and then include module
foreach (module ${modules})
  include_directories("${CMAKE_CURRENT_SOURCE_DIR}/${module}")
  include_directories("${CMAKE_CURRENT_BINARY_DIR}/${module}")
endforeach()
# include modules
foreach (module ${modules})
  add_subdirectory(${module})
endforeach()
# declare dependencies on headers generation
set(modules_with_libs ${modules})
list(REMOVE_ITEM modules_with_libs include matrix_drivers)
foreach (module ${modules_with_libs})
  foreach (module2 ${modules})
    add_dependencies(pastix_${module} ${module2}_headers)
  endforeach()
endforeach()
foreach (module2 ${modules})
  add_dependencies(read_matrix ${module2}_headers)
endforeach()

macro(solver_rules _output_files _sources_files)
  foreach(_source_file ${_sources_files})

    set(_source_file "${CMAKE_CURRENT_SOURCE_DIR}/${_source_file}")
    string(REGEX REPLACE "^(.*).c$" "\\1" _prefix "${_source_file}")

    add_custom_command(OUTPUT ${_prefix}_he.c COMMAND cp ${_source_file} ${_prefix}_he.c DEPENDS ${_source_file} )
    add_custom_command(OUTPUT ${_prefix}_sy.c COMMAND cp ${_source_file} ${_prefix}_sy.c DEPENDS ${_source_file} )
    add_custom_command(OUTPUT ${_prefix}_po.c COMMAND cp ${_source_file} ${_prefix}_po.c DEPENDS ${_source_file} )
    add_custom_command(OUTPUT ${_prefix}_ge.c COMMAND cp ${_source_file} ${_prefix}_ge.c DEPENDS ${_source_file} )

    set_source_files_properties(${_prefix}_he.c PROPERTIES COMPILE_FLAGS "-UCHOL_SOPALIN -DHERMITIAN" )
    set_source_files_properties(${_prefix}_sy.c PROPERTIES COMPILE_FLAGS "-UCHOL_SOPALIN" )
    set_source_files_properties(${_prefix}_po.c PROPERTIES COMPILE_FLAGS "-DCHOL_SOPALIN" )
    set_source_files_properties(${_prefix}_ge.c PROPERTIES COMPILE_FLAGS "-DCHOL_SOPALIN -DSOPALIN_LU" )

    list(APPEND ${_output_files}
      ${_prefix}_he.c
      ${_prefix}_sy.c
      ${_prefix}_po.c
      ${_prefix}_ge.c
      )

  endforeach()
endmacro()


#
# Build the pastix library
# Create the define for Pastix sources that will be updated in each
# subdrectory
#
set(PASTIX_LIB_SRCS
# Files that are fully converted
  #
  graph/graph.c
  graph/graph_isolate.c
  graph/graph_prepare.c
  graph/graph_symmetrize.c
  #
  order/order.c
  order/order_add_isolate.c
  order/order_check.c
  order/order_find_supernodes.c
  order/order_io.c
  order/pastix_task_order.c
  #
  fax/amalgamate.c
  fax/symbol_fax_graph.c
  fax/symbol_kass.c
  fax/symbol_kass_build.c
  fax/symbol_kass_csr.c
  fax/symbol_kass_direct.c
  fax/symbol_kass_level.c
  fax/pastix_task_symbfact.c
  #

# Files that still require some changes

  common/errors.c
  common/integer.c
  common/memory.c
#  common/trace.c
  graph/graph_io.c
#
#
  symbol/dof.c
  symbol/dof_io.c
  symbol/symbol_base.c
  symbol/symbol.c
  symbol/symbol_check.c
  symbol/symbol_cost.c
  symbol/symbol_draw.c
  symbol/symbol_io.c
  symbol/symbol_tree.c
  symbol/symbol_rustine.c
#
  ${generated_files}
  )



set(PASTIX_ALL_SRCS
  #
  graph/graph.c
  graph/graph_isolate.c
  graph/graph_prepare.c
  graph/graph_symmetrize.c
  #
  order/order.c
  order/order_add_isolate.c
  order/order_check.c
  order/order_find_supernodes.c
  order/order_io.c
  order/pastix_task_order.c
  #
  fax/amalgamate.c
  fax/symbol_fax_graph.c
  fax/symbol_kass.c
  fax/symbol_kass_build.c
  fax/symbol_kass_csr.c
  fax/symbol_kass_direct.c
  fax/symbol_kass_level.c
  fax/pastix_task_symbfact.c
  #
#  ${PASTIX_LIB_SRCS}
  order/order_compute_scotch.c
  #order/order_compute_ptscotch.c
  order/order_compute_metis.c
)

if(PASTIX_WITH_STARPU)
 list(APPEND PASTIX_LIB_SRCS ${PASTIX_STARPU_SRCS})
endif(PASTIX_WITH_STARPU)

if(PASTIX_ORDERING_SCOTCH) # AND HAVE_SCOTCH)
  set(PASTIX_LIB_SRCS
    ${PASTIX_LIB_SRCS}
    order/order_compute_scotch.c
    )
endif()
if(PASTIX_ORDERING_PTSCOTCH) # AND HAVE_PTSCOTCH)
  set(PASTIX_LIB_SRCS
    ${PASTIX_LIB_SRCS}
    order/order_compute_ptscotch.c
    )
endif()
if(PASTIX_ORDERING_METIS) # AND HAVE_METIS)
  list(APPEND PASTIX_LIB_SRCS
    order/order_compute_metis.c
    )
endif()

add_library(pastix ${PASTIX_LIB_SRCS})


foreach (module2 ${modules})
  add_dependencies(pastix ${module2}_headers)
endforeach()

install(TARGETS pastix
  RUNTIME DESTINATION bin
  ARCHIVE DESTINATION lib
  LIBRARY DESTINATION lib)

add_subdirectory(example)

FIND_PACKAGE(Doxygen)
if (DOXYGEN_FOUND)
  option(BUILD_DOCUMENTATION "Use Doxygen to create the HTML based API documentation" ON)
else (DOXYGEN_FOUND)
  option(BUILD_DOCUMENTATION "Use Doxygen to create the HTML based API documentation" OFF)
endif(DOXYGEN_FOUND)

if(BUILD_DOCUMENTATION)
  if (NOT DOXYGEN_FOUND)
    message(FATAL_ERROR
      "Doxygen is needed to build the documentation. Please install it correctly")
  endif()

  set(PASTIX_DOX_SRCS )
  foreach( _file ${PASTIX_ALL_SRCS} )
    set(PASTIX_DOX_SRCS "${PASTIX_DOX_SRCS} ${PROJECT_SOURCE_DIR}/${_file}" )
  endforeach()

  #-- Configure the Template Doxyfile for our specific project
  configure_file(${CMAKE_CURRENT_SOURCE_DIR}/docs/doxygen/Doxyfile.in
                 ${CMAKE_CURRENT_BINARY_DIR}/docs/doxygen/Doxyfile @ONLY IMMEDIATE )
  #-- Add a custom target to run Doxygen when ever the project is built
  add_custom_target (docs
    COMMAND ${DOXYGEN_EXECUTABLE} ${CMAKE_CURRENT_BINARY_DIR}/docs/doxygen/Doxyfile
    SOURCES ${CMAKE_CURRENT_BINARY_DIR}/docs/doxygen/Doxyfile )

endif()


#-- Add a custom target to run Doxygen when ever the project is built
add_custom_target (tags
  COMMAND etags ${PASTIX_LIB_SRCS}
  DEPENDS ${PASTIX_LIB_SRCS} )
